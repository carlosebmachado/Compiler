/* Generated By:JavaCC: Do not edit this line. Token.java Version 5.0 */
/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package br.univali.ttoproject.compiler.parser;

/**
 * Describes the input token stream.
 */

public class Token implements java.io.Serializable {

    /**
     * The version identifier for this Serializable class. Increment only if the
     * <i>serialized</i> form of the class changes.
     */
    private static final long serialVersionUID = 1L;

    /**
     * An integer that describes the kind of this token. This numbering system is
     * determined by JavaCCParser, and a table of these numbers is stored in the
     * file ...Constants.java.
     */
    public int kind;

    /**
     * The line number of the first character of this Token.
     */
    public int beginLine;
    /**
     * The column number of the first character of this Token.
     */
    public int beginColumn;
    /**
     * The line number of the last character of this Token.
     */
    public int endLine;
    /**
     * The column number of the last character of this Token.
     */
    public int endColumn;

    /**
     * The string image of the token.
     */
    public String image;

    /**
     * A reference to the next regular (non-special) token from the input stream. If
     * this is the last token from the input stream, or if the token manager has not
     * read tokens beyond this one, this field is set to null. This is true only if
     * this token is also a regular token. Otherwise, see below for a description of
     * the contents of this field.
     */
    public Token next;

    /**
     * This field is used to access special tokens that occur prior to this token,
     * but after the immediately preceding regular (non-special) token. If there are
     * no such special tokens, this field is set to null. When there are more than
     * one such special token, this field refers to the last of these special
     * tokens, which in turn refers to the next previous special token through its
     * specialToken field, and so on until the first special token (whose
     * specialToken field is null). The next fields of special tokens refer to other
     * special tokens that immediately follow it (without an intervening regular
     * token). If there is no such token, this field is null.
     */
    public Token specialToken;

    /**
     * An optional attribute value of the Token. Tokens which are not used as
     * syntactic sugar will often contain meaningful values that will be used later
     * on by the compiler or interpreter. This attribute value is often different
     * from the image. Any subclass of Token that actually wants to return a
     * non-null value can override this method as appropriate.
     */
    public Object getValue() {
        return null;
    }

    /**
     * No-argument constructor
     */
    public Token() {
    }

    /**
     * Constructs a new token for the specified Image.
     */
    public Token(int kind) {
        this(kind, null);
    }

    /**
     * Constructs a new token for the specified Image and Kind.
     */
    public Token(int kind, String image) {
        this.kind = kind;
        this.image = image;
    }

    /**
     * Returns the image.
     */
    public String toString() {
        return image;
    }

    /**
     * Returns a new Token object, by default. However, if you want, you can create
     * and return subclass objects based on the value of ofKind. Simply add the
     * cases to the switch for all those special cases. For example, if you have a
     * subclass of Token called IDToken that you want to create if ofKind is ID,
     * simply add something like :
     * <p>
     * case MyParserConstants.ID : return new IDToken(ofKind, image);
     * <p>
     * to the following switch statement. Then you can cast matchedToken variable to
     * the appropriate type and use sit in your lexical actions.
     */
    public static CategorizedToken newToken(int ofKind, String image) {
        switch (ofKind) {
            case ParserConstants.PROGRAM:
            case ParserConstants.DEFINE:
            case ParserConstants.NOT:
            case ParserConstants.VARIABLE:
            case ParserConstants.IS:
            case ParserConstants.NATURAL_TYPE:
            case ParserConstants.REAL_TYPE:
            case ParserConstants.CHAR_TYPE:
            case ParserConstants.BOOLEAN_TYPE:
            case ParserConstants.EXECUTE:
            case ParserConstants.SET:
            case ParserConstants.TO:
            case ParserConstants.GET:
            case ParserConstants.PUT:
            case ParserConstants.VERIFY:
            case ParserConstants.LOOP:
            case ParserConstants.WHILE:
            case ParserConstants.DO:
                return new CategorizedToken(TokenCategory.Keyword, ofKind, image);
            case ParserConstants.IDENTIFIER:
                return new CategorizedToken(TokenCategory.Identifier, ParserConstants.IDENTIFIER, image);
            case ParserConstants.NATURAL_CONST:
                return new CategorizedToken(TokenCategory.NaturalConstant, ofKind, image);
            case ParserConstants.REAL_CONST:
                return new CategorizedToken(TokenCategory.RealConstant, ofKind, image);
            case ParserConstants.CHAR_CONST:
                return new CategorizedToken(TokenCategory.CharConstant, ofKind, image);
            case ParserConstants.TRUE:
            case ParserConstants.FALSE:
                return new CategorizedToken(TokenCategory.BooleanConstant, ofKind, image);
            case ParserConstants.EOF:
            case ParserConstants.LBRACE:
            case ParserConstants.RBRACE:
            case ParserConstants.LPARENTHESES:
            case ParserConstants.RPARANTHESES:
            case ParserConstants.LBRACKET:
            case ParserConstants.RBRACKET:
            case ParserConstants.DOT:
            case ParserConstants.COMMA:
            case ParserConstants.PLUS:
            case ParserConstants.MINUS:
            case ParserConstants.POWER:
            case ParserConstants.MULTIPLICATION:
            case ParserConstants.DIVISION:
            case ParserConstants.INTEGER_DIVISION:
            case ParserConstants.REST:
            case ParserConstants.EQUAL:
            case ParserConstants.DIFFERENT:
            case ParserConstants.SMALLER:
            case ParserConstants.GREATER:
            case ParserConstants.SMALLER_EQUAL:
            case ParserConstants.GREATER_EQUAL:
            case ParserConstants.AND:
            case ParserConstants.OR:
            case ParserConstants.NOT_SYMBOL:
            case ParserConstants.HEADER:
                return new CategorizedToken(TokenCategory.SpecialSymbol, ofKind, image);
            default:
                return new CategorizedToken(TokenCategory.Unknown, ofKind, image);
        }
    }

    public static Token newToken(int ofKind) {
        return newToken(ofKind, null);
    }

}
/*
 * JavaCC - OriginalChecksum=013ca11c0293a101b3d80e7fd4da66b8 (do not edit this
 * line)
 */
